
--- === utils.consolidateMenus ===
---
--- A status panel similar to Bartender's is created which can house menus generated by
--- hs.menubar.  Currently it is located in the upper right of the screen and can show
--- any hs.menubar menu which actually provides a menu (i.e. not one that just triggers
--- a function via setClickCallback).
---
--- It is very limited at present and is more of a "proof-of-concept" and a stage where
--- I can identify things I might want to add or modify in the existing core modules to
--- provide better functionality.
---


local module = {
--[=[
    _NAME        = 'consolidateMenus.lua',
    _VERSION     = 'the 1st digit of Pi/0',
    _URL         = 'https://github.com/asmagill/hammerspoon-config',
    _LICENSE     = [[ See README.md ]]
    _DESCRIPTION = [[

        Build a panel of hs.menubar items elsewhere than the menubar

        Sort of a mini _Bartender_ "proof of concept" sort of thing, but limited
        to our own menus, unfortunately

    ]],
    _TODO        = [[

        [x] Document methods
        [ ] Update hs.menubar so that there are "getters" for the title and icon
        [ ] Allow the panel to be placed elsewhere
        [ ] Allow panel icons, color, etc. to be set via methods
        [ ] timer to check on changes to titles and icons
        [ ] test the hell out of this
        [ ] Update hs.drawing to allow right click on ClickCallbacks
        [ ] with timer, can also set up autohide
        [ ] cleanup menuRemove -- too much repitition
        [ ] proper __gc; not sure about this one, but it isn't crashing on reload, so...

        Maybe:

        [ ] update hs.image and/or hs.drawing so it can provide an "inverse" of an image
              to allow mimicking OS X's dark style
        [ ] allow cmd clicking on items to move them around?
              will need to understand dragging events better
        [ ] can hs.drawing be updated so ClickCallback doesn't bring Hammerspoon forward?
              if not, may need to add a module to create regions (invisible rectangular areas)
              which can receive events and handle it that way... ugh

    ]]
--]=]
}

local menubar = require("hs.menubar")
local fnutils = require("hs.fnutils")
local screen  = require("hs.screen")
local drawing = require("hs.drawing")
local image   = require("hs.image")
local mouse   = require("hs.mouse")

local hMargin, wMargin = 2, 2

local boxStroke   = { red = 0.0, green = 0.0, blue = 0.0, alpha = 0.8 }
local boxStrokeW  = 2
local boxFill     = { red = 1.0, green = 1.0, blue = 1.0, alpha = 0.5 }
local boxHeight   = 2 * hMargin + screen.mainScreen():frame().y - screen.mainScreen():fullFrame().y
local boxWidth    = boxHeight
local iconHeight  = boxHeight - 2 * hMargin
local iconWidth   = boxWidth  - 2 * wMargin

local myMenuImageOn  = image.imageFromName(image.systemImageNames.RemoveTemplate)
local myMenuImageOff = image.imageFromName(image.systemImageNames.AddTemplate)

local CMIcount = 0

local myMenuItems = {}
local myMenuBar = drawing.rectangle{}:setRoundedRectRadii(wMargin, hMargin):
                      setStroke(boxStroke ~= nil):setStrokeWidth(boxStrokeW or 0):setStrokeColor(boxStroke):
                      setFill(boxFill ~= nil):setFillColor(boxFill):setBehaviorByLabels{"canJoinAllSpaces"}

-- private variables and methods -----------------------------------------

local myMenuVisible = false
local myMenu

local panelToggle = function() return myMenuVisible and module.panelHide() or module.panelShow() end
myMenu = menubar.new():setClickCallback(panelToggle):setIcon(myMenuImageOff)

-- Public interface ------------------------------------------------------

module.menuUserdata = myMenu
module.CMImenuItems = myMenuItems

--- utils.consolidateMenus.panelShow()
--- Function
--- Shows the status panel.
---
--- Parameters:
---  * None
---
--- Returns:
---  * true
module.panelShow = function()
    myMenu:setIcon(myMenuImageOn)
    myMenuBar:setFrame{
        x = screen.mainScreen():fullFrame().x + screen.mainScreen():fullFrame().w - boxWidth * (1 + #myMenuItems),
        y = screen.mainScreen():frame().y,
        h = boxHeight,
        w = boxWidth * (1 + #myMenuItems)
    }
    myMenuBar:show()
    local i = 0
    fnutils.map(myMenuItems, function(menu)
        menu.drawing:setTopLeft{
            x = (screen.mainScreen():frame().x + screen.mainScreen():frame().w) - (#myMenuItems + .5 - i) * boxWidth + wMargin,
            y = screen.mainScreen():frame().y + hMargin,
        }:show()
        i = i + 1
    end)
    myMenuVisible = true
    return true
end

--- utils.consolidateMenus.panelHide()
--- Function
--- Hides the status panel.
---
--- Parameters:
---  * None
---
--- Returns:
---  * true
module.panelHide = function()
    fnutils.map(myMenuItems, function(menu) menu.drawing:hide() end)
    myMenuBar:hide()
    myMenu:setIcon(myMenuImageOff)
    myMenuVisible = false
    return true
end

--- utils.consolidateMenus.panelToggle()
--- Function
--- Toggles the visibility of the status panel.
---
--- Parameters:
---  * None
---
--- Returns:
---  * true
module.panelToggle = panelToggle

--- utils.consolidateMenus.addMenu(menu, icon, [position[, autoRemove]]) -> table
--- Function
--- Add a menubar item to the status panel.
---
--- Parameters:
---  * menu - the menu item to be added to the status panel.  This must be the menubar userdata returned when the menu was created with hs.menubar.new
---  * icon - currently limited to an hs.image or a string to be displayed as the menus icon in the status panel.  Currently this is only really useful if the string consists of 1 or 2 unicode characters, as it doesn't grow the space and will be truncated to fit.
---  * position - optional parameter specifying where to insert the new item.  Defaults to 1, which is the leftmost position.  If the number is less than 1, then it will be subtracted from the number of items currently in the panel (e.g. 0 is the rightmost position, shifting everything else left)
---  * autoremove - optional parameter which defaults to false.  If this is true, then the menu will be automatically removed from the menubar when it is inserted into the panel.
---
--- Returns:
---  * a table containing the hs.menubar userdata the hs.drawing userdata, and some other relevant information about this status item.  Usually you will not need this, but it might be handy to cache or save if you intend to remove the menu later, as this is one method of removal which doesn't rely on the menus position.  See utils.consolidateMenus.removeMenu()
---
--- Notes:
---  * if the menu is autoremoved from the menubar when it is added, it will be returned to the menubar when it is removed from the panel.
module.addMenu = function(menu, icon, position, autoRemove)
    if type(autoRemove) ~= "boolean" then autoRemove = false end
    position = position or 1
    if position < 1 then position = #myMenuItems + 1 - position end

    CMIcount = CMIcount + 1

    local CMI = setmetatable({ CMIcount = CMIcount},{
        __tostring = function(_)
            return string.format("-- consolidateMenus: (0x%04x)", _.CMIcount)
        end,
    })

    if type(icon) == "string" then
        CMI.recheckTitle = (icon == "title") -- need to implement getters for menubar icon and text first
        CMI.drawing = drawing.text({h = iconHeight, w = iconWidth}, icon):setTextSize(iconHeight * .75)
    else
        CMI.drawing = drawing.image({h = iconHeight, w = iconWidth}, icon)
    end
    CMI.drawing:setBehaviorByLabels{"canJoinAllSpaces"}:setClickCallback(function()
        CMI.menu:popupMenu{
            x = (screen.mainScreen():frame().x + screen.mainScreen():frame().w) - (#myMenuItems + .5 - math.ceil((screen.mainScreen():frame().w - mouse.get().x) / boxWidth)) * boxWidth,
            y = screen.mainScreen():frame().y + boxHeight + 2 * hMargin,
        }
    end)
    CMI.menu       = menu
    CMI.autoRemove = autoRemove
    table.insert(myMenuItems, position, CMI)
    if myMenuVisible then module.panelShow() end
    if autoRemove then
        menu:removeFromMenuBar()
    end

    return CMI
end

--- utils.consolidateMenus.removeMenu(menu)
--- Function
--- Remove a menubar item from the status panel.
---
--- Parameters:
---  * menu - the menu item to be removed from the status panel.  The menu can be specified as:
---    * number - its position in the status panel where 1 is the leftmost item
---    * menubar userdata - the actual menubar userdata returned when the menu was created with hs.menubar.new
---    * consolidateMenus table - the return value from the utils.consolidateMenus.addMenu() function.
---
--- Returns:
---  * true if the menuitem was found and removed from the status panel, false if it was not.  An error will also be printed to the Hammerspoon console.
---
--- Notes:
---  * if the menu was autoremoved from the menubar when it was first added, it will be returned to the menubar after its removal from the panel.
module.removeMenu = function(menu)
    if type(menu) == "userdata" then   -- by menu object itself
        for i,v in ipairs(myMenuItems) do
            if v.menuUserdata == menu then
                table.remove(myMenuItems, i)
                if myMenuVisible then module.panelShow() end
                if CMI.autoRemove then menu:returnToMenuBar() end
                return true
            end
        end
        print("++ unable to find menu "..tostring(menu).." for removal")
        return false
    elseif type(menu) == "number" then -- by position in the menu
        table.remove(myMenuItems, menu)
        if myMenuVisible then module.panelShow() end
        if CMI.autoRemove then menu:returnToMenuBar() end
        return true
    elseif type(menu) == "table" then  -- by the returned object from addMenu
        for i,v in ipairs(myMenuItems) do
            if v == menu then
                table.remove(myMenuItems, i)
                if myMenuVisible then module.panelShow() end
                if CMI.autoRemove then menu:returnToMenuBar() end
                return true
            end
        end
        print("++ unable to find menu "..tostring(menu).." for removal")
        return false
    else
        print("++ unknown menu type "..type(menu).." passed into removeMenu")
        return false
    end
end
-- Return Module Object --------------------------------------------------

return setmetatable(module, {
    __gc = function(_)
        if myMenuUserdata then
            myMenuUserdata:delete()
            myMenu = nil
        end
        if myMenuItems then
            fnutils.map(myMenuItems, function(obj) obj:delete() end)
            myMenuItems = nil
        end
        if myMenuBar then
            myMenuBar:delete()
            myMenuBar = nil
        end
    end,
})
